# Readme

## Pull request summary

### Key knowledge

#### What can route do?

1. config route for displaying certain component when visited.
2. encapsulate some shared data in parent route (layout, loader, action, error element)
   a. handle error with certain component
   b. create similar layout for multiple page
3. executed loader function when certain route is visited before rendering component
   a. data returned from loader function will exist when page component start rendering

I still not quite understand how react router provides better error handling.

#### Nested route

For defining similar layout structure and sharing data

- root route ('/'): main layout wrapper and `children` property
  - `<Outlet/>`: define where the child route should be placed
  - `errorElement` define fallback UI for error handling
- index: default displayed route when parent route is active
- relative path (without leading ('/'): path are appended to current route
- path identifier: dynamic route matching that can be retrieved with `useParams`
- id: unique identifier for accessing route data

#### Loader and action

- loader: pre-fetch data before component renders (GET)
- action: handle form submission and data mutations (PUT, PATCH, DELETE)
- `params` and `request` will be passed to loader and action
  - params: path identifier without `useParams`
  - request: info about submission
- nearest loader/ action will be applied by default ( like `useLoaderData`)

  - laoder can be specified with `id` property (`useRouteLoaderData(id)`)

#### Deferred loading pattern

Deferred loading pattern provides these benefits:

- page can render immediately while data is loading (progressively loading UI)
- multiple data fetches can load independently
  - component can show partial content while waiting for data
  - useful when you have multiple data dependencies
- display loading indicator from `Suspense` instead of blank page

```javascript
// Without defer/Await pattern:
async function loader() {
  const events = await loadEvents(); // Blocks until data is loaded
  return { events };
}

// With defer/Await pattern:
function loader() {
  return {
    events: loadEvents(), // Returns immediately with a Promise
  };
}
```

##### Deferred loading process

1. loader `return { events: loadEvents() }` (promise wrapped in object)
2. `useLoaderData()` get this object
3. `<Suspense>` provides fallback UI while loading
4. `<Await resolve={events}>` waits for promise to resolve
5. children callback receives resolved data

#### `<Await>` component vs `await` keyword

`<Await>` provide deferred loading by:

1. accept the promise from `useLoaderData`
2. wait for it to resolve
3. call its children function with the resolved data
4. all while letting `Suspense` show a loading state

`await` in loader function allows better UX with progressive loading, since:

- critical data loads first
- secondary data loads in background

```javascript
// EventDetail.jsx
// Individual data fetching functions
async function loadEvent(id) { ... }
async function loadEvents() { ... }

// Loader function for the route
export async function loader({ params }) {
  const id = params.eventId;
  return {
    event: await loadEvent(id),    // ← AWAITED
    events: loadEvents()           // ← NOT AWAITED
  };
}
```

With `await` keyword - 'wait for this event data before showing the page'

- this make sense since it's the primary data needed for the page
- navigation won't complete until this data is available

Without `awiat` keyword - 'start loading but don't wait for completion'

- this create a deferred loading pattern
- works with `<Suspense>` and `<Await>` for progressive loading

Workflow generated by AI:

```javascript
// When navigation starts:
loader() {
  │
  ├─► await loadEvent(id)   // 1. Wait for main event
  │    │
  │    └─► User sees nothing yet
  │
  ├─► loadEvents()          // 2. Start loading events list
  │    │
  │    └─► Returns Promise immediately
  │
  └─► Return both          // 3. Navigation completes
       │
       └─► Page renders with:
           - Main event data (already loaded)
           - Events list (still loading)
```

#### How react router processes form submission with `action`

`<Form>` component:

- captures form submission
- prevent default
- pass form data to `action` function

`action` function:

- receive form data (`request.formData()`)
- process data (sending server request)
- returns response or redirect

`useActionData` Hook:

- access `action`'s returned data from `action`
- usually used for validation errors
- update UI based on submission results

`useNavigation` Hook:

- monitor submission state

### Related knowledge

#### `useEffect` vs `loader`/ `action`

Timing is the most important difference:

- `useEffect` runs AFTER component renders, which can lead to layout shifts
- `loader` runs BEFORE component renders, ensuring data is ready when component mounts

In addition:

- `loader/action` has built-in error handling through `errorElement`
- `loader/action` separates data fetching from components providing better DX

##### Use Cases for `useEffect` and `loader`/ `action`

`useEffect` is better for:

- component-specific side effects
  - cleanup operations
  - setting up subscriptions (WebSocket connections)
- real-time data updates
  - adding/ removing event listeners

`loader/action` is better for:

- route-level data requirements
  - initial data fetching
  - navigation-triggered data loading
  - parallel data loading
- form submissions
  - data mutations
